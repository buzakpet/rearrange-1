PROGRAMMING WITH FILES
Windows, Linux, and MacOS use file systems to organize how data is stored on the system.
Data is usually organized in a disk and saved in files which are organized in a tree sructure. We know where a resource is stored and we can acces it using its path.
An Absolute path: is a full path to the resource in the file system.
e.g C:\Users\Jordan on windows and /home/Jordan on linux is the absolute path to the file named Jordan. It called an absolute path because we can access that file from any loation in on operating system.
A relative paths: use only a portion of the path to show where the resources is located in relation to the current working directory. Relative paths are kind of a shortcut we use so that we dont have to write out the full file path.

READING FILES
For larger jobs, we would not be developing data hard coded into the script we are working with, we most often than not need to get values from an external source, or files especially processing large chunks of data.
Python give us file objects which we can use to read and write to files

 file = open("spider.txt")
 
 what we've done is create a new file object and assigned it to the variable called file. the parameter we've passed to the open function is the name of the file we want to open.
 
 We have assumed here that the file we want to read is in the same directory with the scrip we a running. but we can also pass in an absolute path to open a file in a different directory.
 When we open a file like we've done, the operating system checks if we have the right permisions to access that file, and then gives our code a file descriptor: a token, generated by the OS, that allows program to do more operations with the file.
 In python this file descriptor is stored as an attribute of the file object. The file objects gives us a buncj of methods that we can use to operate with the file. With this file object we can read the content of the file an print them to the screen.
 
 print(file.readline())
 
 Here, we use the readline() method. it lets us read a single line of the file.
 if we call it again, it will read the next line of the file
 So how does this work? Well each time we call the readline method, the file updates the current position of the in the file, so it keeps moving forward.
 We can also call the read method which reads from the current positon of the file until the end.
 
 print(file.read())
 
 Just like the readline() method, the read() method starts to read from the current position of the file, but instead of just one line, it reads all the way to the end.
 
 Finally, we'll close a file using the close method.
 
 file.close()
 
 This open-use-close pattern is the typical way of working with files in most programming languages. It is a good idea to close files after we've open them for good reasons.
 1.When a file is open in your script, your file system usually locks it down and so no other program or script can use it until its finished
 2.There is a limitted number of file descriptors that you can create before your file system runs out of them. Although the number is large but this can quickly finish when we open files in a loop. 
 3.Leaving files open can lead to race conditions, which occur when multiple proccesses try to modify and read from resource at the same time.
 Since it can be hard to keep track of all the files you've opened and remember to close them. fotunately the creators of python agreed. So to help remember to close a file after we are done with it, python lets us create a block of code by using the key word "with"
 
 with open("spider.txt") as file:
     print(file.readline())
     
 When we use a with block, python closes the file for us.
 Both the open-use-close and the with approach have their advantages.
 Using a with block is a way to open and work on a single file and have file automatically close at the end of the block.
 On the flip side, using open outside the block means we can use the file object in other parts of our code, and so we are not restricted to a single block.
 
 ITERATING THROUGH FILES
 If we want to print the text in upper case, we run the code
 with open("spider.txt") as file:
    for line in file:
       print(line.upper())
 
 we find spaces between each line, how did they get there? and what can we do to remove them? 
 What happens is that the file has a new character at the end of every line, and so when python reads the file line by line, the line variable would always have a new line character at the end. In other words, the new character is not removed when calling readline(), and when we call the print function, it adds another new line creating an empty line. 
 We can is the string method strip to remove all tabs, and white space.
 
  with open("spider.txt") as file:
    for line in file:
       print(line.strip().upper())
       
 We could also read file lines into a list and do something with the list like sort file contents. To do this we use the readlines() method. Note this different from the readline() method.

>>> file = open("Using Python to Interact with the Operating System")
>>> lines = file.readlines()
>>> file.close()
>>> lines.sort()
>>> print(line)

recall that unlike the sorted() funtion, the sort() method returns a modified version of the existing list.

Now, the first thing we observe is that the list returned is sorted in alphabetical order, and the first line is the one whose letter comes first in the alphabet.
Also we can see that python displays the newline symbol \n when printing the list of strings. This explicitly shows that newline characters exist at the end ofthose lines. 
In general to diplay a character that is not printable, python uses escape sequence with \, example \n or \t.
*****Caution Methods like read() or readline() that holds a whole file at once are useful, but we should be careful when reading the entire contents of a file into a variable of our programs. If the file is very large, it could take up a lot of our memory, which will lead to poor performance. 

WRITING TO FILES
with open("novel.txt", "w") as file:
   file.write("It was a dark and stormy night")
   
From the code above we can see that we use the with block pattern to open a file called novel.txt. We also the use the write method on the file object writes contents to it instead of reading from it. But there is another argument to the open method labaled "w". File objects can be opened in several different modes. A mode is similar to a file permision. it governs what we can do with a file we just opened. By default the file object uses an "r" mode which means read only. This is why we didnt have specify the "r" mode when reading from the files in our previous examples. The "w" tells python that we want to open the file for writing only. If the file does not exits, python would create it. If the file does exists then the current contents would be overwriten by whatever we decide to write in our python script.
When we open a file in write only mode, when we try to read to it, the interpreter would raise an error. 
If we want to add contents to a file that already exists, we use a different mode called "a" for appending contents at the end of the file, or "r+" for read write mode, where we can both read contents and overwrite it.
**** If you open a file for writing and the file already exists, the old contents will be deleted as soon as the file is opened.
So double check that you're opening the correct file.
for example if you are generating a log file for the events that your program came across, you probably want to open the file using the "a", because opening it with "w" would mean that we would overwrite any previous entry in that file, and thats not a good idea for a log file. 
Or if we are generating a report and we want to write it out to a new file using the "w", we probably want to chek if the file already exists to avoid loosing any previous update.
Lastly we see a number 30 at the end of the execution of the block. This is the retrurn value of the write method. When succesful the method returns the number of characters that it wrote, in this case 30

WORKING WITH FILES
We may need to delete rename or move files or we might need info about a file like the last time it was modified, or its current size.
To explore the functions we can carry out on files, we'll use the os module. This module provides a layer of absraction between the python and the operating system. It allows to interact with the underlying system without us knowing whether we are working on a windows, mac, linux or any other OS supported by python.
BUT, Paths can be different across different operating systems. So, whenever we're using an absolute path in our code, we need to make sure we can provide alternatives for the platform we want to support. 
The os module lets us do pretty much all the same task that we can normally do when working with files from the command line.
We can change a files permisions, delete or rename files through our code.
TO delete a file we can use the remove function in the os module.

 import os
 os.remove("novel.txt")
 
This code removes the file named novel.txt from the current directory
We can easily rename a file with the rename() function, the first parameter is the rename function is the old name of the file, while the second parameter is the new name of the file.

os.rename("old_file_name", "new_file_name")

if we try to do this for a file that doesnt exsit we get a file not found error. So, how do we check if a file exist or not? THERE IS  A SUB MODULE INSIDE THE OS MODULE FOR DEALING WITH THINGS RELATED TO FILE INFORMATION, LIKE WHETHER THE EXIST OR NOT. THIS IS CALLED THE os.path SUB-MODULE and we can use the exist function to check whether a file exists  or not.

os.path.exists("finished_mastepiece.txt")

os.path.exists("userlist.txt")

MORE FILE INFORMATION
To get how big a file is we can use the get_size() function which will return the file size in bytes

os.path.getsize("/home/obaji/Documents/Week 2 Using Python to Interact with the Operating System") 

to check when a file was last modified the getmtime() function comes up very handy.

os.path.getmtime("spider.txt")

The long number returned to us us a timestamp. Spcifically it is a unix time stamp. It represents the number of seconds since the 1970, because this is when unix created their file systems, and prior to this day there is no other file created.
We can use a datetime module to make it easier to reas

>>> timestamp = os.path.getmtime("spider.txt")
>>> datetime.datetime.fromtimestamp(timestamp)

We are using the fromtimestamp() method inside the datetime class, inside the datetime module. Makes the date more understandeable.
We can work with both relative and full file paths.
If we need to specify the absolute file path of the function, we will use the abspath function. Note that after we use the abspath funtion we do not need to specify the full path name anymore.
This is usefull if we want to store a files full path or access the file no matter directory its in.

DIRECTORIES
To check which current directory your python program is executing in we can use the getcwd() method. in unix this is pwd.
To create a directory we use the mkdir() function which is the same in windows and linux.
os.mkdir("new_dir")

We can change directory in python by using the chdir() function and passing the directory we want to change into as a parameter. We can achieve this using absolute or relative path.

os.chdir("new_dir")

To remove directory we can use the rmdir() function 

os.rmdir("newer_dir")

This function would only work if the directory is empty. In order to delete a directory, we need to delete all files and subdirectory inside that directory.
How do we find out what contents are inside that directory?
1.The os.listdir() function gives all the files and subdirectories in a given directory

os.listdir("website")

This would give us a list of directories and files inside the given directory as strings, so we dont know if they're directories or files.
TO find out what the are we use functions like os.path.isdir(). If we want to know if any of the given strings in the list produced by calling the function os.listdir() is a directory, we use the function os.path.join() to create a full path.

dir = "website"

for name in os.listdir(dir):
   fullname = os.path.join(dir, name)
   if os.path.isdir(fullname):
      print("{} is a directory".format(fullname))
   else:
      print("{} is a file".format(fullname))
      
Recall that the .path sub module handles related to directory and file information.

We first define a dir variable that holds the directory we want to check. Then we iterate through the file names contained in the directory. after we create a full path with the names of the files in the given directory, we check to see if the full path is a directory using os.path.isdir() function. If it is we print a mesage saying that that item in the directory is a directory. The esle block runs and prints a statement saying the item is a file if the item is actually a file.
The join function does not just add a slash to between two strings, well it lets us be independent from the operating system. 
In Linux and MacOS, the portion of  a file are split using a forward slash(/).
On Windows, they're split using a bakslash(\).
By Using os.path.join() function we ensure that our scrip will work across all platforms. This is a handy little tool that helps us avoid errors 

WHAT IS CSV
When we talked about reading files, we considered files that have text line after the other. Formats give data structure and computers love structure and precision. Before computer processes a data set, it helps to know how that data would be arranged. If we know how data would be represented, it will be easy to extract meaning from it.
For example, if we have a file that contains one line per machine, and details of users that are logged into that machine, then when we read the file we know how to parse it to get the information that we want. Parsing a file means analyzing its contents to correctly structure the data. we use a lot of different file formats to structure, store and transfer data. example HTML is a markup format which defines the content of a web page, JSON is data interchange format commonly used to parse data between computer on network, CSV is used to store data as segments of text seperated by commas.
In jobs as an IT specialist, it, might be helpful to convert the output of file to a format that would be easier to parse later on. for example the df command prints the currently used disk space in a format that easier to read by human eye, but turning the info into a CSV makes it much easier to work with later in my script. It might be helful to think of a CSV file, were each line corresponds to a row and each comma serparated field corresponds to a column

READING CSV FILES
CSV is simply stored in plain text, and each line in a CSV file represents a single data record. each field in that record is seperated by a comma, with the contents of the field stored between the commas, for example we will read contents from a csv file using the reader() function.

csv_file.txt
Sabrina Green,802-867-5309,System Administrator
Eli Jones,684-3481127,IT specialist
Melody Daniels,846-687-7436,Programmer
Charlie Rivera,698-746-3357,Web Developer

Python Standard Library includes a module that allows us to read, create and manipulate csv files, called csv.

import csv
f = open("csv_file.txt")
csv_f = csv.reader(f)
for row in csv_f:
   name, phone, role = row
   print("Name: {}, Phone: {}, Role: {}".format(name,phone,role)
   
In this code we unpacked the row, so that we dont have to use indexes to access each element in the list. i.e, we could have used row[0] to access the list, but this soon becomes very tidious. So to be on the safe side, we unpack the row this way.

GENERATING CSV
Here we will use the writer() function to write contents to the CSV file. We will start by storing the datawe wnat to export in a list.
hosts = [["workstation.local", "192.168.25.46"], ["webserver.cloud", "10.2.5.6"]]
with open('hosts.csv', 'w') as hosts_csv:
   writer = csv.writer(hosts_csv)
   writer.writerows(hosts)

In the above code, after we open the csv file and set it up for writing, we could either use writerow() which would write one row at a time, or writerows() which will write all rows immediately. In this case we already have the data we want to write so we will call write rows

READING AND WRITING CSV FILES WITH DICTIONARIES
If the csv file had a lot of information to include, it would soon get hard to keep track of which columns to corresponds to which position in the row. For example:

name,version,status,users
MailTree,5.34,production,324
CalDoor,1.25.1,beta,22
Chartty,Chicken,0.34,alpha,4

Checkout how the first line of the file includes the names of each of the fields. We can profit from this additional information using DictReader, which is a slightly different reader that is also provided by the csv module. This reader turns each row of the data in the csv into a dictionary. we can access the data using the column names instead of the position in the row. The top most row serves as the columns names.

with open('software.csv') as software:
   reader = csv.DictReader(software)
   for row in reader:
      print(("{} has {} users").format(row["name"], row["users]))
      
Two important things to point out here;
1. The other of the fields in the file does not matter. We can just use the name of the field instead.

We can use DictWriter in a similar way to generate a csv file from a content of a list of dictionaries. This means that each element in the list will be a row in the file. and the value of each field will come out of each of the dictionaries. For this to work, will also need to parse a list of the keys that we want to be stored in the file when creating the writer.
First we need a list data we want to store. 

users = [{"name": "Sol Mansi", "username": "solm", "department": "IT infrastructure"}, {"name": "Lio Nelson", "username": "lion", "department": "User Experience Research"}, {"name": "Charlie Grey", "username": "greyc", "department": "Development"}]

Above is the list of dictionaries we want to write to the file. Each has a name, username, department as keys.
Now let us write this to a file

keys = ["name", "username", "department"]
with open('by_department.csv', 'w') as by_department:
   writer = csv.DictWriter(by_department, fieldnames=keys)
   writer.writeheader()
   writer.writerows(users)

In the code above, we first define the list of keys we want to use to write to the file. Then we open the file for writing, next we create a DictWriter parsing the keys we have identiified before. Then we call two different methods on the writer object, the writerheader() creates the first line of the csv based on the keys we have parsed. The writerows() methods will turn the list of dictionaries into lines in that file.